/* automatically generated by rust-bindgen */

pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type va_list = __builtin_va_list;
pub type csh = usize;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cs_arch {
    CS_ARCH_ARM = 0,
    CS_ARCH_ARM64 = 1,
    CS_ARCH_MIPS = 2,
    CS_ARCH_X86 = 3,
    CS_ARCH_PPC = 4,
    CS_ARCH_SPARC = 5,
    CS_ARCH_SYSZ = 6,
    CS_ARCH_XCORE = 7,
    CS_ARCH_MAX = 8,
    CS_ARCH_ALL = 65535,
}
impl cs_mode {
    pub const CS_MODE_ARM: cs_mode = cs_mode::CS_MODE_LITTLE_ENDIAN;
}
impl cs_mode {
    pub const CS_MODE_MICRO: cs_mode = cs_mode::CS_MODE_THUMB;
}
impl cs_mode {
    pub const CS_MODE_MIPS3: cs_mode = cs_mode::CS_MODE_MCLASS;
}
impl cs_mode {
    pub const CS_MODE_MIPS32R6: cs_mode = cs_mode::CS_MODE_V8;
}
impl cs_mode {
    pub const CS_MODE_V9: cs_mode = cs_mode::CS_MODE_THUMB;
}
impl cs_mode {
    pub const CS_MODE_MIPS32: cs_mode = cs_mode::CS_MODE_32;
}
impl cs_mode {
    pub const CS_MODE_MIPS64: cs_mode = cs_mode::CS_MODE_64;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cs_mode {
    CS_MODE_LITTLE_ENDIAN = 0,
    CS_MODE_16 = 2,
    CS_MODE_32 = 4,
    CS_MODE_64 = 8,
    CS_MODE_THUMB = 16,
    CS_MODE_MCLASS = 32,
    CS_MODE_V8 = 64,
    CS_MODE_MIPSGP64 = 128,
    CS_MODE_BIG_ENDIAN = -2147483648,
}
pub type cs_malloc_t =
    ::std::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::std::os::raw::c_void>;
pub type cs_calloc_t = ::std::option::Option<
    unsafe extern "C" fn(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void,
>;
pub type cs_realloc_t = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type cs_free_t = ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>;
pub type cs_vsnprintf_t = ::std::option::Option<
    unsafe extern "C" fn(
        str: *mut ::std::os::raw::c_char,
        size: usize,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cs_opt_mem {
    pub malloc: cs_malloc_t,
    pub calloc: cs_calloc_t,
    pub realloc: cs_realloc_t,
    pub free: cs_free_t,
    pub vsnprintf: cs_vsnprintf_t,
}
#[test]
fn bindgen_test_layout_cs_opt_mem() {
    assert_eq!(
        ::std::mem::size_of::<cs_opt_mem>(),
        40usize,
        concat!("Size of: ", stringify!(cs_opt_mem))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_opt_mem>(),
        8usize,
        concat!("Alignment of ", stringify!(cs_opt_mem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_opt_mem>())).malloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_opt_mem),
            "::",
            stringify!(malloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_opt_mem>())).calloc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_opt_mem),
            "::",
            stringify!(calloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_opt_mem>())).realloc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_opt_mem),
            "::",
            stringify!(realloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_opt_mem>())).free as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_opt_mem),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_opt_mem>())).vsnprintf as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_opt_mem),
            "::",
            stringify!(vsnprintf)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cs_opt_type {
    CS_OPT_INVALID = 0,
    CS_OPT_SYNTAX = 1,
    CS_OPT_DETAIL = 2,
    CS_OPT_MODE = 3,
    CS_OPT_MEM = 4,
    CS_OPT_SKIPDATA = 5,
    CS_OPT_SKIPDATA_SETUP = 6,
}
impl cs_opt_value {
    pub const CS_OPT_SYNTAX_DEFAULT: cs_opt_value = cs_opt_value::CS_OPT_OFF;
}
impl cs_opt_value {
    pub const CS_OPT_SYNTAX_NOREGNAME: cs_opt_value = cs_opt_value::CS_OPT_ON;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cs_opt_value {
    CS_OPT_OFF = 0,
    CS_OPT_ON = 3,
    CS_OPT_SYNTAX_INTEL = 1,
    CS_OPT_SYNTAX_ATT = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cs_op_type {
    CS_OP_INVALID = 0,
    CS_OP_REG = 1,
    CS_OP_IMM = 2,
    CS_OP_MEM = 3,
    CS_OP_FP = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cs_group_type {
    CS_GRP_INVALID = 0,
    CS_GRP_JUMP = 1,
    CS_GRP_CALL = 2,
    CS_GRP_RET = 3,
    CS_GRP_INT = 4,
    CS_GRP_IRET = 5,
}
pub type cs_skipdata_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        code: *const u8,
        code_size: usize,
        offset: usize,
        user_data: *mut ::std::os::raw::c_void,
    ) -> usize,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cs_opt_skipdata {
    pub mnemonic: *const ::std::os::raw::c_char,
    pub callback: cs_skipdata_cb_t,
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cs_opt_skipdata() {
    assert_eq!(
        ::std::mem::size_of::<cs_opt_skipdata>(),
        24usize,
        concat!("Size of: ", stringify!(cs_opt_skipdata))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_opt_skipdata>(),
        8usize,
        concat!("Alignment of ", stringify!(cs_opt_skipdata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_opt_skipdata>())).mnemonic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_opt_skipdata),
            "::",
            stringify!(mnemonic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_opt_skipdata>())).callback as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_opt_skipdata),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_opt_skipdata>())).user_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_opt_skipdata),
            "::",
            stringify!(user_data)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum arm_shifter {
    ARM_SFT_INVALID = 0,
    ARM_SFT_ASR = 1,
    ARM_SFT_LSL = 2,
    ARM_SFT_LSR = 3,
    ARM_SFT_ROR = 4,
    ARM_SFT_RRX = 5,
    ARM_SFT_ASR_REG = 6,
    ARM_SFT_LSL_REG = 7,
    ARM_SFT_LSR_REG = 8,
    ARM_SFT_ROR_REG = 9,
    ARM_SFT_RRX_REG = 10,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum arm_cc {
    ARM_CC_INVALID = 0,
    ARM_CC_EQ = 1,
    ARM_CC_NE = 2,
    ARM_CC_HS = 3,
    ARM_CC_LO = 4,
    ARM_CC_MI = 5,
    ARM_CC_PL = 6,
    ARM_CC_VS = 7,
    ARM_CC_VC = 8,
    ARM_CC_HI = 9,
    ARM_CC_LS = 10,
    ARM_CC_GE = 11,
    ARM_CC_LT = 12,
    ARM_CC_GT = 13,
    ARM_CC_LE = 14,
    ARM_CC_AL = 15,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum arm_mem_barrier {
    ARM_MB_INVALID = 0,
    ARM_MB_RESERVED_0 = 1,
    ARM_MB_OSHLD = 2,
    ARM_MB_OSHST = 3,
    ARM_MB_OSH = 4,
    ARM_MB_RESERVED_4 = 5,
    ARM_MB_NSHLD = 6,
    ARM_MB_NSHST = 7,
    ARM_MB_NSH = 8,
    ARM_MB_RESERVED_8 = 9,
    ARM_MB_ISHLD = 10,
    ARM_MB_ISHST = 11,
    ARM_MB_ISH = 12,
    ARM_MB_RESERVED_12 = 13,
    ARM_MB_LD = 14,
    ARM_MB_ST = 15,
    ARM_MB_SY = 16,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum arm_op_type {
    ARM_OP_INVALID = 0,
    ARM_OP_REG = 1,
    ARM_OP_IMM = 2,
    ARM_OP_MEM = 3,
    ARM_OP_FP = 4,
    ARM_OP_CIMM = 64,
    ARM_OP_PIMM = 65,
    ARM_OP_SETEND = 66,
    ARM_OP_SYSREG = 67,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum arm_setend_type {
    ARM_SETEND_INVALID = 0,
    ARM_SETEND_BE = 1,
    ARM_SETEND_LE = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum arm_cpsmode_type {
    ARM_CPSMODE_INVALID = 0,
    ARM_CPSMODE_IE = 2,
    ARM_CPSMODE_ID = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum arm_cpsflag_type {
    ARM_CPSFLAG_INVALID = 0,
    ARM_CPSFLAG_F = 1,
    ARM_CPSFLAG_I = 2,
    ARM_CPSFLAG_A = 4,
    ARM_CPSFLAG_NONE = 16,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum arm_vectordata_type {
    ARM_VECTORDATA_INVALID = 0,
    ARM_VECTORDATA_I8 = 1,
    ARM_VECTORDATA_I16 = 2,
    ARM_VECTORDATA_I32 = 3,
    ARM_VECTORDATA_I64 = 4,
    ARM_VECTORDATA_S8 = 5,
    ARM_VECTORDATA_S16 = 6,
    ARM_VECTORDATA_S32 = 7,
    ARM_VECTORDATA_S64 = 8,
    ARM_VECTORDATA_U8 = 9,
    ARM_VECTORDATA_U16 = 10,
    ARM_VECTORDATA_U32 = 11,
    ARM_VECTORDATA_U64 = 12,
    ARM_VECTORDATA_P8 = 13,
    ARM_VECTORDATA_F32 = 14,
    ARM_VECTORDATA_F64 = 15,
    ARM_VECTORDATA_F16F64 = 16,
    ARM_VECTORDATA_F64F16 = 17,
    ARM_VECTORDATA_F32F16 = 18,
    ARM_VECTORDATA_F16F32 = 19,
    ARM_VECTORDATA_F64F32 = 20,
    ARM_VECTORDATA_F32F64 = 21,
    ARM_VECTORDATA_S32F32 = 22,
    ARM_VECTORDATA_U32F32 = 23,
    ARM_VECTORDATA_F32S32 = 24,
    ARM_VECTORDATA_F32U32 = 25,
    ARM_VECTORDATA_F64S16 = 26,
    ARM_VECTORDATA_F32S16 = 27,
    ARM_VECTORDATA_F64S32 = 28,
    ARM_VECTORDATA_S16F64 = 29,
    ARM_VECTORDATA_S16F32 = 30,
    ARM_VECTORDATA_S32F64 = 31,
    ARM_VECTORDATA_U16F64 = 32,
    ARM_VECTORDATA_U16F32 = 33,
    ARM_VECTORDATA_U32F64 = 34,
    ARM_VECTORDATA_F64U16 = 35,
    ARM_VECTORDATA_F32U16 = 36,
    ARM_VECTORDATA_F64U32 = 37,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_op_mem {
    pub base: ::std::os::raw::c_uint,
    pub index: ::std::os::raw::c_uint,
    pub scale: ::std::os::raw::c_int,
    pub disp: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_arm_op_mem() {
    assert_eq!(
        ::std::mem::size_of::<arm_op_mem>(),
        16usize,
        concat!("Size of: ", stringify!(arm_op_mem))
    );
    assert_eq!(
        ::std::mem::align_of::<arm_op_mem>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_op_mem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arm_op_mem>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_op_mem),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arm_op_mem>())).index as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_op_mem),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arm_op_mem>())).scale as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_op_mem),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arm_op_mem>())).disp as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_op_mem),
            "::",
            stringify!(disp)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cs_arm_op {
    pub vector_index: ::std::os::raw::c_int,
    pub shift: cs_arm_op__bindgen_ty_1,
    pub type_: arm_op_type,
    pub __bindgen_anon_1: cs_arm_op__bindgen_ty_2,
    pub subtracted: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cs_arm_op__bindgen_ty_1 {
    pub type_: arm_shifter,
    pub value: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cs_arm_op__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cs_arm_op__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(cs_arm_op__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_arm_op__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(cs_arm_op__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm_op__bindgen_ty_1>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm_op__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm_op__bindgen_ty_1>())).value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm_op__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cs_arm_op__bindgen_ty_2 {
    pub reg: ::std::os::raw::c_uint,
    pub imm: i32,
    pub fp: f64,
    pub mem: arm_op_mem,
    pub setend: arm_setend_type,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_cs_arm_op__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<cs_arm_op__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(cs_arm_op__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_arm_op__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(cs_arm_op__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm_op__bindgen_ty_2>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm_op__bindgen_ty_2),
            "::",
            stringify!(reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm_op__bindgen_ty_2>())).imm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm_op__bindgen_ty_2),
            "::",
            stringify!(imm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm_op__bindgen_ty_2>())).fp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm_op__bindgen_ty_2),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm_op__bindgen_ty_2>())).mem as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm_op__bindgen_ty_2),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm_op__bindgen_ty_2>())).setend as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm_op__bindgen_ty_2),
            "::",
            stringify!(setend)
        )
    );
}
impl ::std::fmt::Debug for cs_arm_op__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "cs_arm_op__bindgen_ty_2 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_cs_arm_op() {
    assert_eq!(
        ::std::mem::size_of::<cs_arm_op>(),
        40usize,
        concat!("Size of: ", stringify!(cs_arm_op))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_arm_op>(),
        8usize,
        concat!("Alignment of ", stringify!(cs_arm_op))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm_op>())).vector_index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm_op),
            "::",
            stringify!(vector_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm_op>())).shift as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm_op),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm_op>())).type_ as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm_op),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm_op>())).subtracted as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm_op),
            "::",
            stringify!(subtracted)
        )
    );
}
impl ::std::fmt::Debug for cs_arm_op {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "cs_arm_op {{ vector_index: {:?}, shift: {:?}, type: {:?}, __bindgen_anon_1: {:?}, subtracted: {:?} }}" , self . vector_index , self . shift , self . type_ , self . __bindgen_anon_1 , self . subtracted )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cs_arm {
    pub usermode: bool,
    pub vector_size: ::std::os::raw::c_int,
    pub vector_data: arm_vectordata_type,
    pub cps_mode: arm_cpsmode_type,
    pub cps_flag: arm_cpsflag_type,
    pub cc: arm_cc,
    pub update_flags: bool,
    pub writeback: bool,
    pub mem_barrier: arm_mem_barrier,
    pub op_count: u8,
    pub operands: [cs_arm_op; 36usize],
}
#[test]
fn bindgen_test_layout_cs_arm() {
    assert_eq!(
        ::std::mem::size_of::<cs_arm>(),
        1480usize,
        concat!("Size of: ", stringify!(cs_arm))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_arm>(),
        8usize,
        concat!("Alignment of ", stringify!(cs_arm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm>())).usermode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm),
            "::",
            stringify!(usermode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm>())).vector_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm),
            "::",
            stringify!(vector_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm>())).vector_data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm),
            "::",
            stringify!(vector_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm>())).cps_mode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm),
            "::",
            stringify!(cps_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm>())).cps_flag as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm),
            "::",
            stringify!(cps_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm>())).cc as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm),
            "::",
            stringify!(cc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm>())).update_flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm),
            "::",
            stringify!(update_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm>())).writeback as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm),
            "::",
            stringify!(writeback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm>())).mem_barrier as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm),
            "::",
            stringify!(mem_barrier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm>())).op_count as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm),
            "::",
            stringify!(op_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm>())).operands as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm),
            "::",
            stringify!(operands)
        )
    );
}
impl ::std::fmt::Debug for cs_arm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "cs_arm {{ usermode: {:?}, vector_size: {:?}, vector_data: {:?}, cps_mode: {:?}, cps_flag: {:?}, cc: {:?}, update_flags: {:?}, writeback: {:?}, mem_barrier: {:?}, op_count: {:?}, operands: [{}] }}" , self . usermode , self . vector_size , self . vector_data , self . cps_mode , self . cps_flag , self . cc , self . update_flags , self . writeback , self . mem_barrier , self . op_count , self . operands . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) )
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum arm64_shifter {
    ARM64_SFT_INVALID = 0,
    ARM64_SFT_LSL = 1,
    ARM64_SFT_MSL = 2,
    ARM64_SFT_LSR = 3,
    ARM64_SFT_ASR = 4,
    ARM64_SFT_ROR = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum arm64_extender {
    ARM64_EXT_INVALID = 0,
    ARM64_EXT_UXTB = 1,
    ARM64_EXT_UXTH = 2,
    ARM64_EXT_UXTW = 3,
    ARM64_EXT_UXTX = 4,
    ARM64_EXT_SXTB = 5,
    ARM64_EXT_SXTH = 6,
    ARM64_EXT_SXTW = 7,
    ARM64_EXT_SXTX = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum arm64_cc {
    ARM64_CC_INVALID = 0,
    ARM64_CC_EQ = 1,
    ARM64_CC_NE = 2,
    ARM64_CC_HS = 3,
    ARM64_CC_LO = 4,
    ARM64_CC_MI = 5,
    ARM64_CC_PL = 6,
    ARM64_CC_VS = 7,
    ARM64_CC_VC = 8,
    ARM64_CC_HI = 9,
    ARM64_CC_LS = 10,
    ARM64_CC_GE = 11,
    ARM64_CC_LT = 12,
    ARM64_CC_GT = 13,
    ARM64_CC_LE = 14,
    ARM64_CC_AL = 15,
    ARM64_CC_NV = 16,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum arm64_pstate {
    ARM64_PSTATE_INVALID = 0,
    ARM64_PSTATE_SPSEL = 5,
    ARM64_PSTATE_DAIFSET = 30,
    ARM64_PSTATE_DAIFCLR = 31,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum arm64_vas {
    ARM64_VAS_INVALID = 0,
    ARM64_VAS_8B = 1,
    ARM64_VAS_16B = 2,
    ARM64_VAS_4H = 3,
    ARM64_VAS_8H = 4,
    ARM64_VAS_2S = 5,
    ARM64_VAS_4S = 6,
    ARM64_VAS_1D = 7,
    ARM64_VAS_2D = 8,
    ARM64_VAS_1Q = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum arm64_vess {
    ARM64_VESS_INVALID = 0,
    ARM64_VESS_B = 1,
    ARM64_VESS_H = 2,
    ARM64_VESS_S = 3,
    ARM64_VESS_D = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum arm64_barrier_op {
    ARM64_BARRIER_INVALID = 0,
    ARM64_BARRIER_OSHLD = 1,
    ARM64_BARRIER_OSHST = 2,
    ARM64_BARRIER_OSH = 3,
    ARM64_BARRIER_NSHLD = 5,
    ARM64_BARRIER_NSHST = 6,
    ARM64_BARRIER_NSH = 7,
    ARM64_BARRIER_ISHLD = 9,
    ARM64_BARRIER_ISHST = 10,
    ARM64_BARRIER_ISH = 11,
    ARM64_BARRIER_LD = 13,
    ARM64_BARRIER_ST = 14,
    ARM64_BARRIER_SY = 15,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum arm64_op_type {
    ARM64_OP_INVALID = 0,
    ARM64_OP_REG = 1,
    ARM64_OP_IMM = 2,
    ARM64_OP_MEM = 3,
    ARM64_OP_FP = 4,
    ARM64_OP_CIMM = 64,
    ARM64_OP_REG_MRS = 65,
    ARM64_OP_REG_MSR = 66,
    ARM64_OP_PSTATE = 67,
    ARM64_OP_SYS = 68,
    ARM64_OP_PREFETCH = 69,
    ARM64_OP_BARRIER = 70,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum arm64_prefetch_op {
    ARM64_PRFM_INVALID = 0,
    ARM64_PRFM_PLDL1KEEP = 1,
    ARM64_PRFM_PLDL1STRM = 2,
    ARM64_PRFM_PLDL2KEEP = 3,
    ARM64_PRFM_PLDL2STRM = 4,
    ARM64_PRFM_PLDL3KEEP = 5,
    ARM64_PRFM_PLDL3STRM = 6,
    ARM64_PRFM_PLIL1KEEP = 9,
    ARM64_PRFM_PLIL1STRM = 10,
    ARM64_PRFM_PLIL2KEEP = 11,
    ARM64_PRFM_PLIL2STRM = 12,
    ARM64_PRFM_PLIL3KEEP = 13,
    ARM64_PRFM_PLIL3STRM = 14,
    ARM64_PRFM_PSTL1KEEP = 17,
    ARM64_PRFM_PSTL1STRM = 18,
    ARM64_PRFM_PSTL2KEEP = 19,
    ARM64_PRFM_PSTL2STRM = 20,
    ARM64_PRFM_PSTL3KEEP = 21,
    ARM64_PRFM_PSTL3STRM = 22,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm64_op_mem {
    pub base: ::std::os::raw::c_uint,
    pub index: ::std::os::raw::c_uint,
    pub disp: i32,
}
#[test]
fn bindgen_test_layout_arm64_op_mem() {
    assert_eq!(
        ::std::mem::size_of::<arm64_op_mem>(),
        12usize,
        concat!("Size of: ", stringify!(arm64_op_mem))
    );
    assert_eq!(
        ::std::mem::align_of::<arm64_op_mem>(),
        4usize,
        concat!("Alignment of ", stringify!(arm64_op_mem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arm64_op_mem>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm64_op_mem),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arm64_op_mem>())).index as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm64_op_mem),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arm64_op_mem>())).disp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm64_op_mem),
            "::",
            stringify!(disp)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cs_arm64_op {
    pub vector_index: ::std::os::raw::c_int,
    pub vas: arm64_vas,
    pub vess: arm64_vess,
    pub shift: cs_arm64_op__bindgen_ty_1,
    pub ext: arm64_extender,
    pub type_: arm64_op_type,
    pub __bindgen_anon_1: cs_arm64_op__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cs_arm64_op__bindgen_ty_1 {
    pub type_: arm64_shifter,
    pub value: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cs_arm64_op__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cs_arm64_op__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(cs_arm64_op__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_arm64_op__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(cs_arm64_op__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm64_op__bindgen_ty_1>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm64_op__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm64_op__bindgen_ty_1>())).value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm64_op__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cs_arm64_op__bindgen_ty_2 {
    pub reg: ::std::os::raw::c_uint,
    pub imm: i64,
    pub fp: f64,
    pub mem: arm64_op_mem,
    pub pstate: arm64_pstate,
    pub sys: ::std::os::raw::c_uint,
    pub prefetch: arm64_prefetch_op,
    pub barrier: arm64_barrier_op,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_cs_arm64_op__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<cs_arm64_op__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(cs_arm64_op__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_arm64_op__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(cs_arm64_op__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm64_op__bindgen_ty_2>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm64_op__bindgen_ty_2),
            "::",
            stringify!(reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm64_op__bindgen_ty_2>())).imm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm64_op__bindgen_ty_2),
            "::",
            stringify!(imm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm64_op__bindgen_ty_2>())).fp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm64_op__bindgen_ty_2),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm64_op__bindgen_ty_2>())).mem as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm64_op__bindgen_ty_2),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cs_arm64_op__bindgen_ty_2>())).pstate as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm64_op__bindgen_ty_2),
            "::",
            stringify!(pstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm64_op__bindgen_ty_2>())).sys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm64_op__bindgen_ty_2),
            "::",
            stringify!(sys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cs_arm64_op__bindgen_ty_2>())).prefetch as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm64_op__bindgen_ty_2),
            "::",
            stringify!(prefetch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cs_arm64_op__bindgen_ty_2>())).barrier as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm64_op__bindgen_ty_2),
            "::",
            stringify!(barrier)
        )
    );
}
impl ::std::fmt::Debug for cs_arm64_op__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "cs_arm64_op__bindgen_ty_2 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_cs_arm64_op() {
    assert_eq!(
        ::std::mem::size_of::<cs_arm64_op>(),
        48usize,
        concat!("Size of: ", stringify!(cs_arm64_op))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_arm64_op>(),
        8usize,
        concat!("Alignment of ", stringify!(cs_arm64_op))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm64_op>())).vector_index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm64_op),
            "::",
            stringify!(vector_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm64_op>())).vas as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm64_op),
            "::",
            stringify!(vas)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm64_op>())).vess as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm64_op),
            "::",
            stringify!(vess)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm64_op>())).shift as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm64_op),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm64_op>())).ext as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm64_op),
            "::",
            stringify!(ext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm64_op>())).type_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm64_op),
            "::",
            stringify!(type_)
        )
    );
}
impl ::std::fmt::Debug for cs_arm64_op {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "cs_arm64_op {{ vector_index: {:?}, vas: {:?}, vess: {:?}, shift: {:?}, ext: {:?}, type: {:?}, __bindgen_anon_1: {:?} }}" , self . vector_index , self . vas , self . vess , self . shift , self . ext , self . type_ , self . __bindgen_anon_1 )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cs_arm64 {
    pub cc: arm64_cc,
    pub update_flags: bool,
    pub writeback: bool,
    pub op_count: u8,
    pub operands: [cs_arm64_op; 8usize],
}
#[test]
fn bindgen_test_layout_cs_arm64() {
    assert_eq!(
        ::std::mem::size_of::<cs_arm64>(),
        392usize,
        concat!("Size of: ", stringify!(cs_arm64))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_arm64>(),
        8usize,
        concat!("Alignment of ", stringify!(cs_arm64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm64>())).cc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm64),
            "::",
            stringify!(cc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm64>())).update_flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm64),
            "::",
            stringify!(update_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm64>())).writeback as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm64),
            "::",
            stringify!(writeback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm64>())).op_count as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm64),
            "::",
            stringify!(op_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_arm64>())).operands as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_arm64),
            "::",
            stringify!(operands)
        )
    );
}
impl ::std::fmt::Debug for cs_arm64 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "cs_arm64 {{ cc: {:?}, update_flags: {:?}, writeback: {:?}, op_count: {:?}, operands: {:?} }}" , self . cc , self . update_flags , self . writeback , self . op_count , self . operands )
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mips_op_type {
    MIPS_OP_INVALID = 0,
    MIPS_OP_REG = 1,
    MIPS_OP_IMM = 2,
    MIPS_OP_MEM = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mips_op_mem {
    pub base: ::std::os::raw::c_uint,
    pub disp: i64,
}
#[test]
fn bindgen_test_layout_mips_op_mem() {
    assert_eq!(
        ::std::mem::size_of::<mips_op_mem>(),
        16usize,
        concat!("Size of: ", stringify!(mips_op_mem))
    );
    assert_eq!(
        ::std::mem::align_of::<mips_op_mem>(),
        8usize,
        concat!("Alignment of ", stringify!(mips_op_mem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mips_op_mem>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mips_op_mem),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mips_op_mem>())).disp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mips_op_mem),
            "::",
            stringify!(disp)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cs_mips_op {
    pub type_: mips_op_type,
    pub __bindgen_anon_1: cs_mips_op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cs_mips_op__bindgen_ty_1 {
    pub reg: ::std::os::raw::c_uint,
    pub imm: i64,
    pub mem: mips_op_mem,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_cs_mips_op__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cs_mips_op__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(cs_mips_op__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_mips_op__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cs_mips_op__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_mips_op__bindgen_ty_1>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_mips_op__bindgen_ty_1),
            "::",
            stringify!(reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_mips_op__bindgen_ty_1>())).imm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_mips_op__bindgen_ty_1),
            "::",
            stringify!(imm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_mips_op__bindgen_ty_1>())).mem as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_mips_op__bindgen_ty_1),
            "::",
            stringify!(mem)
        )
    );
}
impl ::std::fmt::Debug for cs_mips_op__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "cs_mips_op__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_cs_mips_op() {
    assert_eq!(
        ::std::mem::size_of::<cs_mips_op>(),
        24usize,
        concat!("Size of: ", stringify!(cs_mips_op))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_mips_op>(),
        8usize,
        concat!("Alignment of ", stringify!(cs_mips_op))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_mips_op>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_mips_op),
            "::",
            stringify!(type_)
        )
    );
}
impl ::std::fmt::Debug for cs_mips_op {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "cs_mips_op {{ type: {:?}, __bindgen_anon_1: {:?} }}",
            self.type_, self.__bindgen_anon_1
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cs_mips {
    pub op_count: u8,
    pub operands: [cs_mips_op; 8usize],
}
#[test]
fn bindgen_test_layout_cs_mips() {
    assert_eq!(
        ::std::mem::size_of::<cs_mips>(),
        200usize,
        concat!("Size of: ", stringify!(cs_mips))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_mips>(),
        8usize,
        concat!("Alignment of ", stringify!(cs_mips))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_mips>())).op_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_mips),
            "::",
            stringify!(op_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_mips>())).operands as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_mips),
            "::",
            stringify!(operands)
        )
    );
}
impl ::std::fmt::Debug for cs_mips {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "cs_mips {{ op_count: {:?}, operands: {:?} }}",
            self.op_count, self.operands
        )
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ppc_bc {
    PPC_BC_INVALID = 0,
    PPC_BC_LT = 12,
    PPC_BC_LE = 36,
    PPC_BC_EQ = 76,
    PPC_BC_GE = 4,
    PPC_BC_GT = 44,
    PPC_BC_NE = 68,
    PPC_BC_UN = 108,
    PPC_BC_NU = 100,
    PPC_BC_SO = 140,
    PPC_BC_NS = 132,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ppc_bh {
    PPC_BH_INVALID = 0,
    PPC_BH_PLUS = 1,
    PPC_BH_MINUS = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ppc_reg {
    PPC_REG_INVALID = 0,
    PPC_REG_CARRY = 1,
    PPC_REG_CC = 2,
    PPC_REG_CR0 = 3,
    PPC_REG_CR1 = 4,
    PPC_REG_CR2 = 5,
    PPC_REG_CR3 = 6,
    PPC_REG_CR4 = 7,
    PPC_REG_CR5 = 8,
    PPC_REG_CR6 = 9,
    PPC_REG_CR7 = 10,
    PPC_REG_CTR = 11,
    PPC_REG_F0 = 12,
    PPC_REG_F1 = 13,
    PPC_REG_F2 = 14,
    PPC_REG_F3 = 15,
    PPC_REG_F4 = 16,
    PPC_REG_F5 = 17,
    PPC_REG_F6 = 18,
    PPC_REG_F7 = 19,
    PPC_REG_F8 = 20,
    PPC_REG_F9 = 21,
    PPC_REG_F10 = 22,
    PPC_REG_F11 = 23,
    PPC_REG_F12 = 24,
    PPC_REG_F13 = 25,
    PPC_REG_F14 = 26,
    PPC_REG_F15 = 27,
    PPC_REG_F16 = 28,
    PPC_REG_F17 = 29,
    PPC_REG_F18 = 30,
    PPC_REG_F19 = 31,
    PPC_REG_F20 = 32,
    PPC_REG_F21 = 33,
    PPC_REG_F22 = 34,
    PPC_REG_F23 = 35,
    PPC_REG_F24 = 36,
    PPC_REG_F25 = 37,
    PPC_REG_F26 = 38,
    PPC_REG_F27 = 39,
    PPC_REG_F28 = 40,
    PPC_REG_F29 = 41,
    PPC_REG_F30 = 42,
    PPC_REG_F31 = 43,
    PPC_REG_LR = 44,
    PPC_REG_R0 = 45,
    PPC_REG_R1 = 46,
    PPC_REG_R2 = 47,
    PPC_REG_R3 = 48,
    PPC_REG_R4 = 49,
    PPC_REG_R5 = 50,
    PPC_REG_R6 = 51,
    PPC_REG_R7 = 52,
    PPC_REG_R8 = 53,
    PPC_REG_R9 = 54,
    PPC_REG_R10 = 55,
    PPC_REG_R11 = 56,
    PPC_REG_R12 = 57,
    PPC_REG_R13 = 58,
    PPC_REG_R14 = 59,
    PPC_REG_R15 = 60,
    PPC_REG_R16 = 61,
    PPC_REG_R17 = 62,
    PPC_REG_R18 = 63,
    PPC_REG_R19 = 64,
    PPC_REG_R20 = 65,
    PPC_REG_R21 = 66,
    PPC_REG_R22 = 67,
    PPC_REG_R23 = 68,
    PPC_REG_R24 = 69,
    PPC_REG_R25 = 70,
    PPC_REG_R26 = 71,
    PPC_REG_R27 = 72,
    PPC_REG_R28 = 73,
    PPC_REG_R29 = 74,
    PPC_REG_R30 = 75,
    PPC_REG_R31 = 76,
    PPC_REG_V0 = 77,
    PPC_REG_V1 = 78,
    PPC_REG_V2 = 79,
    PPC_REG_V3 = 80,
    PPC_REG_V4 = 81,
    PPC_REG_V5 = 82,
    PPC_REG_V6 = 83,
    PPC_REG_V7 = 84,
    PPC_REG_V8 = 85,
    PPC_REG_V9 = 86,
    PPC_REG_V10 = 87,
    PPC_REG_V11 = 88,
    PPC_REG_V12 = 89,
    PPC_REG_V13 = 90,
    PPC_REG_V14 = 91,
    PPC_REG_V15 = 92,
    PPC_REG_V16 = 93,
    PPC_REG_V17 = 94,
    PPC_REG_V18 = 95,
    PPC_REG_V19 = 96,
    PPC_REG_V20 = 97,
    PPC_REG_V21 = 98,
    PPC_REG_V22 = 99,
    PPC_REG_V23 = 100,
    PPC_REG_V24 = 101,
    PPC_REG_V25 = 102,
    PPC_REG_V26 = 103,
    PPC_REG_V27 = 104,
    PPC_REG_V28 = 105,
    PPC_REG_V29 = 106,
    PPC_REG_V30 = 107,
    PPC_REG_V31 = 108,
    PPC_REG_VRSAVE = 109,
    PPC_REG_VS0 = 110,
    PPC_REG_VS1 = 111,
    PPC_REG_VS2 = 112,
    PPC_REG_VS3 = 113,
    PPC_REG_VS4 = 114,
    PPC_REG_VS5 = 115,
    PPC_REG_VS6 = 116,
    PPC_REG_VS7 = 117,
    PPC_REG_VS8 = 118,
    PPC_REG_VS9 = 119,
    PPC_REG_VS10 = 120,
    PPC_REG_VS11 = 121,
    PPC_REG_VS12 = 122,
    PPC_REG_VS13 = 123,
    PPC_REG_VS14 = 124,
    PPC_REG_VS15 = 125,
    PPC_REG_VS16 = 126,
    PPC_REG_VS17 = 127,
    PPC_REG_VS18 = 128,
    PPC_REG_VS19 = 129,
    PPC_REG_VS20 = 130,
    PPC_REG_VS21 = 131,
    PPC_REG_VS22 = 132,
    PPC_REG_VS23 = 133,
    PPC_REG_VS24 = 134,
    PPC_REG_VS25 = 135,
    PPC_REG_VS26 = 136,
    PPC_REG_VS27 = 137,
    PPC_REG_VS28 = 138,
    PPC_REG_VS29 = 139,
    PPC_REG_VS30 = 140,
    PPC_REG_VS31 = 141,
    PPC_REG_VS32 = 142,
    PPC_REG_VS33 = 143,
    PPC_REG_VS34 = 144,
    PPC_REG_VS35 = 145,
    PPC_REG_VS36 = 146,
    PPC_REG_VS37 = 147,
    PPC_REG_VS38 = 148,
    PPC_REG_VS39 = 149,
    PPC_REG_VS40 = 150,
    PPC_REG_VS41 = 151,
    PPC_REG_VS42 = 152,
    PPC_REG_VS43 = 153,
    PPC_REG_VS44 = 154,
    PPC_REG_VS45 = 155,
    PPC_REG_VS46 = 156,
    PPC_REG_VS47 = 157,
    PPC_REG_VS48 = 158,
    PPC_REG_VS49 = 159,
    PPC_REG_VS50 = 160,
    PPC_REG_VS51 = 161,
    PPC_REG_VS52 = 162,
    PPC_REG_VS53 = 163,
    PPC_REG_VS54 = 164,
    PPC_REG_VS55 = 165,
    PPC_REG_VS56 = 166,
    PPC_REG_VS57 = 167,
    PPC_REG_VS58 = 168,
    PPC_REG_VS59 = 169,
    PPC_REG_VS60 = 170,
    PPC_REG_VS61 = 171,
    PPC_REG_VS62 = 172,
    PPC_REG_VS63 = 173,
    PPC_REG_RM = 174,
    PPC_REG_CTR8 = 175,
    PPC_REG_LR8 = 176,
    PPC_REG_CR1EQ = 177,
    PPC_REG_ENDING = 178,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ppc_op_type {
    PPC_OP_INVALID = 0,
    PPC_OP_REG = 1,
    PPC_OP_IMM = 2,
    PPC_OP_MEM = 3,
    PPC_OP_CRX = 64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ppc_op_mem {
    pub base: ppc_reg,
    pub disp: i32,
}
#[test]
fn bindgen_test_layout_ppc_op_mem() {
    assert_eq!(
        ::std::mem::size_of::<ppc_op_mem>(),
        8usize,
        concat!("Size of: ", stringify!(ppc_op_mem))
    );
    assert_eq!(
        ::std::mem::align_of::<ppc_op_mem>(),
        4usize,
        concat!("Alignment of ", stringify!(ppc_op_mem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ppc_op_mem>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ppc_op_mem),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ppc_op_mem>())).disp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ppc_op_mem),
            "::",
            stringify!(disp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ppc_op_crx {
    pub scale: ::std::os::raw::c_uint,
    pub reg: ppc_reg,
    pub cond: ppc_bc,
}
#[test]
fn bindgen_test_layout_ppc_op_crx() {
    assert_eq!(
        ::std::mem::size_of::<ppc_op_crx>(),
        12usize,
        concat!("Size of: ", stringify!(ppc_op_crx))
    );
    assert_eq!(
        ::std::mem::align_of::<ppc_op_crx>(),
        4usize,
        concat!("Alignment of ", stringify!(ppc_op_crx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ppc_op_crx>())).scale as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ppc_op_crx),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ppc_op_crx>())).reg as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ppc_op_crx),
            "::",
            stringify!(reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ppc_op_crx>())).cond as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ppc_op_crx),
            "::",
            stringify!(cond)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cs_ppc_op {
    pub type_: ppc_op_type,
    pub __bindgen_anon_1: cs_ppc_op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cs_ppc_op__bindgen_ty_1 {
    pub reg: ppc_reg,
    pub imm: i32,
    pub mem: ppc_op_mem,
    pub crx: ppc_op_crx,
    _bindgen_union_align: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_cs_ppc_op__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cs_ppc_op__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(cs_ppc_op__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_ppc_op__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(cs_ppc_op__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_ppc_op__bindgen_ty_1>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_ppc_op__bindgen_ty_1),
            "::",
            stringify!(reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_ppc_op__bindgen_ty_1>())).imm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_ppc_op__bindgen_ty_1),
            "::",
            stringify!(imm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_ppc_op__bindgen_ty_1>())).mem as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_ppc_op__bindgen_ty_1),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_ppc_op__bindgen_ty_1>())).crx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_ppc_op__bindgen_ty_1),
            "::",
            stringify!(crx)
        )
    );
}
impl ::std::fmt::Debug for cs_ppc_op__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "cs_ppc_op__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_cs_ppc_op() {
    assert_eq!(
        ::std::mem::size_of::<cs_ppc_op>(),
        16usize,
        concat!("Size of: ", stringify!(cs_ppc_op))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_ppc_op>(),
        4usize,
        concat!("Alignment of ", stringify!(cs_ppc_op))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_ppc_op>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_ppc_op),
            "::",
            stringify!(type_)
        )
    );
}
impl ::std::fmt::Debug for cs_ppc_op {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "cs_ppc_op {{ type: {:?}, __bindgen_anon_1: {:?} }}",
            self.type_, self.__bindgen_anon_1
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cs_ppc {
    pub bc: ppc_bc,
    pub bh: ppc_bh,
    pub update_cr0: bool,
    pub op_count: u8,
    pub operands: [cs_ppc_op; 8usize],
}
#[test]
fn bindgen_test_layout_cs_ppc() {
    assert_eq!(
        ::std::mem::size_of::<cs_ppc>(),
        140usize,
        concat!("Size of: ", stringify!(cs_ppc))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_ppc>(),
        4usize,
        concat!("Alignment of ", stringify!(cs_ppc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_ppc>())).bc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_ppc),
            "::",
            stringify!(bc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_ppc>())).bh as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_ppc),
            "::",
            stringify!(bh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_ppc>())).update_cr0 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_ppc),
            "::",
            stringify!(update_cr0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_ppc>())).op_count as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_ppc),
            "::",
            stringify!(op_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_ppc>())).operands as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_ppc),
            "::",
            stringify!(operands)
        )
    );
}
impl ::std::fmt::Debug for cs_ppc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "cs_ppc {{ bc: {:?}, bh: {:?}, update_cr0: {:?}, op_count: {:?}, operands: {:?} }}",
            self.bc, self.bh, self.update_cr0, self.op_count, self.operands
        )
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sparc_cc {
    SPARC_CC_INVALID = 0,
    SPARC_CC_ICC_A = 264,
    SPARC_CC_ICC_N = 256,
    SPARC_CC_ICC_NE = 265,
    SPARC_CC_ICC_E = 257,
    SPARC_CC_ICC_G = 266,
    SPARC_CC_ICC_LE = 258,
    SPARC_CC_ICC_GE = 267,
    SPARC_CC_ICC_L = 259,
    SPARC_CC_ICC_GU = 268,
    SPARC_CC_ICC_LEU = 260,
    SPARC_CC_ICC_CC = 269,
    SPARC_CC_ICC_CS = 261,
    SPARC_CC_ICC_POS = 270,
    SPARC_CC_ICC_NEG = 262,
    SPARC_CC_ICC_VC = 271,
    SPARC_CC_ICC_VS = 263,
    SPARC_CC_FCC_A = 280,
    SPARC_CC_FCC_N = 272,
    SPARC_CC_FCC_U = 279,
    SPARC_CC_FCC_G = 278,
    SPARC_CC_FCC_UG = 277,
    SPARC_CC_FCC_L = 276,
    SPARC_CC_FCC_UL = 275,
    SPARC_CC_FCC_LG = 274,
    SPARC_CC_FCC_NE = 273,
    SPARC_CC_FCC_E = 281,
    SPARC_CC_FCC_UE = 282,
    SPARC_CC_FCC_GE = 283,
    SPARC_CC_FCC_UGE = 284,
    SPARC_CC_FCC_LE = 285,
    SPARC_CC_FCC_ULE = 286,
    SPARC_CC_FCC_O = 287,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sparc_hint {
    SPARC_HINT_INVALID = 0,
    SPARC_HINT_A = 1,
    SPARC_HINT_PT = 2,
    SPARC_HINT_PN = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sparc_op_type {
    SPARC_OP_INVALID = 0,
    SPARC_OP_REG = 1,
    SPARC_OP_IMM = 2,
    SPARC_OP_MEM = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sparc_op_mem {
    pub base: u8,
    pub index: u8,
    pub disp: i32,
}
#[test]
fn bindgen_test_layout_sparc_op_mem() {
    assert_eq!(
        ::std::mem::size_of::<sparc_op_mem>(),
        8usize,
        concat!("Size of: ", stringify!(sparc_op_mem))
    );
    assert_eq!(
        ::std::mem::align_of::<sparc_op_mem>(),
        4usize,
        concat!("Alignment of ", stringify!(sparc_op_mem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sparc_op_mem>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sparc_op_mem),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sparc_op_mem>())).index as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sparc_op_mem),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sparc_op_mem>())).disp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sparc_op_mem),
            "::",
            stringify!(disp)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cs_sparc_op {
    pub type_: sparc_op_type,
    pub __bindgen_anon_1: cs_sparc_op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cs_sparc_op__bindgen_ty_1 {
    pub reg: ::std::os::raw::c_uint,
    pub imm: i32,
    pub mem: sparc_op_mem,
    _bindgen_union_align: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_cs_sparc_op__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cs_sparc_op__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(cs_sparc_op__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_sparc_op__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(cs_sparc_op__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_sparc_op__bindgen_ty_1>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_sparc_op__bindgen_ty_1),
            "::",
            stringify!(reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_sparc_op__bindgen_ty_1>())).imm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_sparc_op__bindgen_ty_1),
            "::",
            stringify!(imm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_sparc_op__bindgen_ty_1>())).mem as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_sparc_op__bindgen_ty_1),
            "::",
            stringify!(mem)
        )
    );
}
impl ::std::fmt::Debug for cs_sparc_op__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "cs_sparc_op__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_cs_sparc_op() {
    assert_eq!(
        ::std::mem::size_of::<cs_sparc_op>(),
        12usize,
        concat!("Size of: ", stringify!(cs_sparc_op))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_sparc_op>(),
        4usize,
        concat!("Alignment of ", stringify!(cs_sparc_op))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_sparc_op>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_sparc_op),
            "::",
            stringify!(type_)
        )
    );
}
impl ::std::fmt::Debug for cs_sparc_op {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "cs_sparc_op {{ type: {:?}, __bindgen_anon_1: {:?} }}",
            self.type_, self.__bindgen_anon_1
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cs_sparc {
    pub cc: sparc_cc,
    pub hint: sparc_hint,
    pub op_count: u8,
    pub operands: [cs_sparc_op; 4usize],
}
#[test]
fn bindgen_test_layout_cs_sparc() {
    assert_eq!(
        ::std::mem::size_of::<cs_sparc>(),
        60usize,
        concat!("Size of: ", stringify!(cs_sparc))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_sparc>(),
        4usize,
        concat!("Alignment of ", stringify!(cs_sparc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_sparc>())).cc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_sparc),
            "::",
            stringify!(cc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_sparc>())).hint as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_sparc),
            "::",
            stringify!(hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_sparc>())).op_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_sparc),
            "::",
            stringify!(op_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_sparc>())).operands as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_sparc),
            "::",
            stringify!(operands)
        )
    );
}
impl ::std::fmt::Debug for cs_sparc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "cs_sparc {{ cc: {:?}, hint: {:?}, op_count: {:?}, operands: {:?} }}",
            self.cc, self.hint, self.op_count, self.operands
        )
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sysz_cc {
    SYSZ_CC_INVALID = 0,
    SYSZ_CC_O = 1,
    SYSZ_CC_H = 2,
    SYSZ_CC_NLE = 3,
    SYSZ_CC_L = 4,
    SYSZ_CC_NHE = 5,
    SYSZ_CC_LH = 6,
    SYSZ_CC_NE = 7,
    SYSZ_CC_E = 8,
    SYSZ_CC_NLH = 9,
    SYSZ_CC_HE = 10,
    SYSZ_CC_NL = 11,
    SYSZ_CC_LE = 12,
    SYSZ_CC_NH = 13,
    SYSZ_CC_NO = 14,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sysz_op_type {
    SYSZ_OP_INVALID = 0,
    SYSZ_OP_REG = 1,
    SYSZ_OP_IMM = 2,
    SYSZ_OP_MEM = 3,
    SYSZ_OP_ACREG = 64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysz_op_mem {
    pub base: u8,
    pub index: u8,
    pub length: u64,
    pub disp: i64,
}
#[test]
fn bindgen_test_layout_sysz_op_mem() {
    assert_eq!(
        ::std::mem::size_of::<sysz_op_mem>(),
        24usize,
        concat!("Size of: ", stringify!(sysz_op_mem))
    );
    assert_eq!(
        ::std::mem::align_of::<sysz_op_mem>(),
        8usize,
        concat!("Alignment of ", stringify!(sysz_op_mem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysz_op_mem>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sysz_op_mem),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysz_op_mem>())).index as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sysz_op_mem),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysz_op_mem>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sysz_op_mem),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysz_op_mem>())).disp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sysz_op_mem),
            "::",
            stringify!(disp)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cs_sysz_op {
    pub type_: sysz_op_type,
    pub __bindgen_anon_1: cs_sysz_op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cs_sysz_op__bindgen_ty_1 {
    pub reg: ::std::os::raw::c_uint,
    pub imm: i64,
    pub mem: sysz_op_mem,
    _bindgen_union_align: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_cs_sysz_op__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cs_sysz_op__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(cs_sysz_op__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_sysz_op__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cs_sysz_op__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_sysz_op__bindgen_ty_1>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_sysz_op__bindgen_ty_1),
            "::",
            stringify!(reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_sysz_op__bindgen_ty_1>())).imm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_sysz_op__bindgen_ty_1),
            "::",
            stringify!(imm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_sysz_op__bindgen_ty_1>())).mem as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_sysz_op__bindgen_ty_1),
            "::",
            stringify!(mem)
        )
    );
}
impl ::std::fmt::Debug for cs_sysz_op__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "cs_sysz_op__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_cs_sysz_op() {
    assert_eq!(
        ::std::mem::size_of::<cs_sysz_op>(),
        32usize,
        concat!("Size of: ", stringify!(cs_sysz_op))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_sysz_op>(),
        8usize,
        concat!("Alignment of ", stringify!(cs_sysz_op))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_sysz_op>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_sysz_op),
            "::",
            stringify!(type_)
        )
    );
}
impl ::std::fmt::Debug for cs_sysz_op {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "cs_sysz_op {{ type: {:?}, __bindgen_anon_1: {:?} }}",
            self.type_, self.__bindgen_anon_1
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cs_sysz {
    pub cc: sysz_cc,
    pub op_count: u8,
    pub operands: [cs_sysz_op; 6usize],
}
#[test]
fn bindgen_test_layout_cs_sysz() {
    assert_eq!(
        ::std::mem::size_of::<cs_sysz>(),
        200usize,
        concat!("Size of: ", stringify!(cs_sysz))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_sysz>(),
        8usize,
        concat!("Alignment of ", stringify!(cs_sysz))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_sysz>())).cc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_sysz),
            "::",
            stringify!(cc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_sysz>())).op_count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_sysz),
            "::",
            stringify!(op_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_sysz>())).operands as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_sysz),
            "::",
            stringify!(operands)
        )
    );
}
impl ::std::fmt::Debug for cs_sysz {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "cs_sysz {{ cc: {:?}, op_count: {:?}, operands: {:?} }}",
            self.cc, self.op_count, self.operands
        )
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum x86_reg {
    X86_REG_INVALID = 0,
    X86_REG_AH = 1,
    X86_REG_AL = 2,
    X86_REG_AX = 3,
    X86_REG_BH = 4,
    X86_REG_BL = 5,
    X86_REG_BP = 6,
    X86_REG_BPL = 7,
    X86_REG_BX = 8,
    X86_REG_CH = 9,
    X86_REG_CL = 10,
    X86_REG_CS = 11,
    X86_REG_CX = 12,
    X86_REG_DH = 13,
    X86_REG_DI = 14,
    X86_REG_DIL = 15,
    X86_REG_DL = 16,
    X86_REG_DS = 17,
    X86_REG_DX = 18,
    X86_REG_EAX = 19,
    X86_REG_EBP = 20,
    X86_REG_EBX = 21,
    X86_REG_ECX = 22,
    X86_REG_EDI = 23,
    X86_REG_EDX = 24,
    X86_REG_EFLAGS = 25,
    X86_REG_EIP = 26,
    X86_REG_EIZ = 27,
    X86_REG_ES = 28,
    X86_REG_ESI = 29,
    X86_REG_ESP = 30,
    X86_REG_FPSW = 31,
    X86_REG_FS = 32,
    X86_REG_GS = 33,
    X86_REG_IP = 34,
    X86_REG_RAX = 35,
    X86_REG_RBP = 36,
    X86_REG_RBX = 37,
    X86_REG_RCX = 38,
    X86_REG_RDI = 39,
    X86_REG_RDX = 40,
    X86_REG_RIP = 41,
    X86_REG_RIZ = 42,
    X86_REG_RSI = 43,
    X86_REG_RSP = 44,
    X86_REG_SI = 45,
    X86_REG_SIL = 46,
    X86_REG_SP = 47,
    X86_REG_SPL = 48,
    X86_REG_SS = 49,
    X86_REG_CR0 = 50,
    X86_REG_CR1 = 51,
    X86_REG_CR2 = 52,
    X86_REG_CR3 = 53,
    X86_REG_CR4 = 54,
    X86_REG_CR5 = 55,
    X86_REG_CR6 = 56,
    X86_REG_CR7 = 57,
    X86_REG_CR8 = 58,
    X86_REG_CR9 = 59,
    X86_REG_CR10 = 60,
    X86_REG_CR11 = 61,
    X86_REG_CR12 = 62,
    X86_REG_CR13 = 63,
    X86_REG_CR14 = 64,
    X86_REG_CR15 = 65,
    X86_REG_DR0 = 66,
    X86_REG_DR1 = 67,
    X86_REG_DR2 = 68,
    X86_REG_DR3 = 69,
    X86_REG_DR4 = 70,
    X86_REG_DR5 = 71,
    X86_REG_DR6 = 72,
    X86_REG_DR7 = 73,
    X86_REG_FP0 = 74,
    X86_REG_FP1 = 75,
    X86_REG_FP2 = 76,
    X86_REG_FP3 = 77,
    X86_REG_FP4 = 78,
    X86_REG_FP5 = 79,
    X86_REG_FP6 = 80,
    X86_REG_FP7 = 81,
    X86_REG_K0 = 82,
    X86_REG_K1 = 83,
    X86_REG_K2 = 84,
    X86_REG_K3 = 85,
    X86_REG_K4 = 86,
    X86_REG_K5 = 87,
    X86_REG_K6 = 88,
    X86_REG_K7 = 89,
    X86_REG_MM0 = 90,
    X86_REG_MM1 = 91,
    X86_REG_MM2 = 92,
    X86_REG_MM3 = 93,
    X86_REG_MM4 = 94,
    X86_REG_MM5 = 95,
    X86_REG_MM6 = 96,
    X86_REG_MM7 = 97,
    X86_REG_R8 = 98,
    X86_REG_R9 = 99,
    X86_REG_R10 = 100,
    X86_REG_R11 = 101,
    X86_REG_R12 = 102,
    X86_REG_R13 = 103,
    X86_REG_R14 = 104,
    X86_REG_R15 = 105,
    X86_REG_ST0 = 106,
    X86_REG_ST1 = 107,
    X86_REG_ST2 = 108,
    X86_REG_ST3 = 109,
    X86_REG_ST4 = 110,
    X86_REG_ST5 = 111,
    X86_REG_ST6 = 112,
    X86_REG_ST7 = 113,
    X86_REG_XMM0 = 114,
    X86_REG_XMM1 = 115,
    X86_REG_XMM2 = 116,
    X86_REG_XMM3 = 117,
    X86_REG_XMM4 = 118,
    X86_REG_XMM5 = 119,
    X86_REG_XMM6 = 120,
    X86_REG_XMM7 = 121,
    X86_REG_XMM8 = 122,
    X86_REG_XMM9 = 123,
    X86_REG_XMM10 = 124,
    X86_REG_XMM11 = 125,
    X86_REG_XMM12 = 126,
    X86_REG_XMM13 = 127,
    X86_REG_XMM14 = 128,
    X86_REG_XMM15 = 129,
    X86_REG_XMM16 = 130,
    X86_REG_XMM17 = 131,
    X86_REG_XMM18 = 132,
    X86_REG_XMM19 = 133,
    X86_REG_XMM20 = 134,
    X86_REG_XMM21 = 135,
    X86_REG_XMM22 = 136,
    X86_REG_XMM23 = 137,
    X86_REG_XMM24 = 138,
    X86_REG_XMM25 = 139,
    X86_REG_XMM26 = 140,
    X86_REG_XMM27 = 141,
    X86_REG_XMM28 = 142,
    X86_REG_XMM29 = 143,
    X86_REG_XMM30 = 144,
    X86_REG_XMM31 = 145,
    X86_REG_YMM0 = 146,
    X86_REG_YMM1 = 147,
    X86_REG_YMM2 = 148,
    X86_REG_YMM3 = 149,
    X86_REG_YMM4 = 150,
    X86_REG_YMM5 = 151,
    X86_REG_YMM6 = 152,
    X86_REG_YMM7 = 153,
    X86_REG_YMM8 = 154,
    X86_REG_YMM9 = 155,
    X86_REG_YMM10 = 156,
    X86_REG_YMM11 = 157,
    X86_REG_YMM12 = 158,
    X86_REG_YMM13 = 159,
    X86_REG_YMM14 = 160,
    X86_REG_YMM15 = 161,
    X86_REG_YMM16 = 162,
    X86_REG_YMM17 = 163,
    X86_REG_YMM18 = 164,
    X86_REG_YMM19 = 165,
    X86_REG_YMM20 = 166,
    X86_REG_YMM21 = 167,
    X86_REG_YMM22 = 168,
    X86_REG_YMM23 = 169,
    X86_REG_YMM24 = 170,
    X86_REG_YMM25 = 171,
    X86_REG_YMM26 = 172,
    X86_REG_YMM27 = 173,
    X86_REG_YMM28 = 174,
    X86_REG_YMM29 = 175,
    X86_REG_YMM30 = 176,
    X86_REG_YMM31 = 177,
    X86_REG_ZMM0 = 178,
    X86_REG_ZMM1 = 179,
    X86_REG_ZMM2 = 180,
    X86_REG_ZMM3 = 181,
    X86_REG_ZMM4 = 182,
    X86_REG_ZMM5 = 183,
    X86_REG_ZMM6 = 184,
    X86_REG_ZMM7 = 185,
    X86_REG_ZMM8 = 186,
    X86_REG_ZMM9 = 187,
    X86_REG_ZMM10 = 188,
    X86_REG_ZMM11 = 189,
    X86_REG_ZMM12 = 190,
    X86_REG_ZMM13 = 191,
    X86_REG_ZMM14 = 192,
    X86_REG_ZMM15 = 193,
    X86_REG_ZMM16 = 194,
    X86_REG_ZMM17 = 195,
    X86_REG_ZMM18 = 196,
    X86_REG_ZMM19 = 197,
    X86_REG_ZMM20 = 198,
    X86_REG_ZMM21 = 199,
    X86_REG_ZMM22 = 200,
    X86_REG_ZMM23 = 201,
    X86_REG_ZMM24 = 202,
    X86_REG_ZMM25 = 203,
    X86_REG_ZMM26 = 204,
    X86_REG_ZMM27 = 205,
    X86_REG_ZMM28 = 206,
    X86_REG_ZMM29 = 207,
    X86_REG_ZMM30 = 208,
    X86_REG_ZMM31 = 209,
    X86_REG_R8B = 210,
    X86_REG_R9B = 211,
    X86_REG_R10B = 212,
    X86_REG_R11B = 213,
    X86_REG_R12B = 214,
    X86_REG_R13B = 215,
    X86_REG_R14B = 216,
    X86_REG_R15B = 217,
    X86_REG_R8D = 218,
    X86_REG_R9D = 219,
    X86_REG_R10D = 220,
    X86_REG_R11D = 221,
    X86_REG_R12D = 222,
    X86_REG_R13D = 223,
    X86_REG_R14D = 224,
    X86_REG_R15D = 225,
    X86_REG_R8W = 226,
    X86_REG_R9W = 227,
    X86_REG_R10W = 228,
    X86_REG_R11W = 229,
    X86_REG_R12W = 230,
    X86_REG_R13W = 231,
    X86_REG_R14W = 232,
    X86_REG_R15W = 233,
    X86_REG_ENDING = 234,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum x86_op_type {
    X86_OP_INVALID = 0,
    X86_OP_REG = 1,
    X86_OP_IMM = 2,
    X86_OP_MEM = 3,
    X86_OP_FP = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum x86_avx_bcast {
    X86_AVX_BCAST_INVALID = 0,
    X86_AVX_BCAST_2 = 1,
    X86_AVX_BCAST_4 = 2,
    X86_AVX_BCAST_8 = 3,
    X86_AVX_BCAST_16 = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum x86_sse_cc {
    X86_SSE_CC_INVALID = 0,
    X86_SSE_CC_EQ = 1,
    X86_SSE_CC_LT = 2,
    X86_SSE_CC_LE = 3,
    X86_SSE_CC_UNORD = 4,
    X86_SSE_CC_NEQ = 5,
    X86_SSE_CC_NLT = 6,
    X86_SSE_CC_NLE = 7,
    X86_SSE_CC_ORD = 8,
    X86_SSE_CC_EQ_UQ = 9,
    X86_SSE_CC_NGE = 10,
    X86_SSE_CC_NGT = 11,
    X86_SSE_CC_FALSE = 12,
    X86_SSE_CC_NEQ_OQ = 13,
    X86_SSE_CC_GE = 14,
    X86_SSE_CC_GT = 15,
    X86_SSE_CC_TRUE = 16,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum x86_avx_cc {
    X86_AVX_CC_INVALID = 0,
    X86_AVX_CC_EQ = 1,
    X86_AVX_CC_LT = 2,
    X86_AVX_CC_LE = 3,
    X86_AVX_CC_UNORD = 4,
    X86_AVX_CC_NEQ = 5,
    X86_AVX_CC_NLT = 6,
    X86_AVX_CC_NLE = 7,
    X86_AVX_CC_ORD = 8,
    X86_AVX_CC_EQ_UQ = 9,
    X86_AVX_CC_NGE = 10,
    X86_AVX_CC_NGT = 11,
    X86_AVX_CC_FALSE = 12,
    X86_AVX_CC_NEQ_OQ = 13,
    X86_AVX_CC_GE = 14,
    X86_AVX_CC_GT = 15,
    X86_AVX_CC_TRUE = 16,
    X86_AVX_CC_EQ_OS = 17,
    X86_AVX_CC_LT_OQ = 18,
    X86_AVX_CC_LE_OQ = 19,
    X86_AVX_CC_UNORD_S = 20,
    X86_AVX_CC_NEQ_US = 21,
    X86_AVX_CC_NLT_UQ = 22,
    X86_AVX_CC_NLE_UQ = 23,
    X86_AVX_CC_ORD_S = 24,
    X86_AVX_CC_EQ_US = 25,
    X86_AVX_CC_NGE_UQ = 26,
    X86_AVX_CC_NGT_UQ = 27,
    X86_AVX_CC_FALSE_OS = 28,
    X86_AVX_CC_NEQ_OS = 29,
    X86_AVX_CC_GE_OQ = 30,
    X86_AVX_CC_GT_OQ = 31,
    X86_AVX_CC_TRUE_US = 32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum x86_avx_rm {
    X86_AVX_RM_INVALID = 0,
    X86_AVX_RM_RN = 1,
    X86_AVX_RM_RD = 2,
    X86_AVX_RM_RU = 3,
    X86_AVX_RM_RZ = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x86_op_mem {
    pub segment: ::std::os::raw::c_uint,
    pub base: ::std::os::raw::c_uint,
    pub index: ::std::os::raw::c_uint,
    pub scale: ::std::os::raw::c_int,
    pub disp: i64,
}
#[test]
fn bindgen_test_layout_x86_op_mem() {
    assert_eq!(
        ::std::mem::size_of::<x86_op_mem>(),
        24usize,
        concat!("Size of: ", stringify!(x86_op_mem))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_op_mem>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_op_mem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_op_mem>())).segment as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_op_mem),
            "::",
            stringify!(segment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_op_mem>())).base as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_op_mem),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_op_mem>())).index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_op_mem),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_op_mem>())).scale as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_op_mem),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_op_mem>())).disp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_op_mem),
            "::",
            stringify!(disp)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cs_x86_op {
    pub type_: x86_op_type,
    pub __bindgen_anon_1: cs_x86_op__bindgen_ty_1,
    pub size: u8,
    pub avx_bcast: x86_avx_bcast,
    pub avx_zero_opmask: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cs_x86_op__bindgen_ty_1 {
    pub reg: x86_reg,
    pub imm: i64,
    pub fp: f64,
    pub mem: x86_op_mem,
    _bindgen_union_align: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_cs_x86_op__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cs_x86_op__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(cs_x86_op__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_x86_op__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cs_x86_op__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_x86_op__bindgen_ty_1>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_x86_op__bindgen_ty_1),
            "::",
            stringify!(reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_x86_op__bindgen_ty_1>())).imm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_x86_op__bindgen_ty_1),
            "::",
            stringify!(imm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_x86_op__bindgen_ty_1>())).fp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_x86_op__bindgen_ty_1),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_x86_op__bindgen_ty_1>())).mem as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_x86_op__bindgen_ty_1),
            "::",
            stringify!(mem)
        )
    );
}
impl ::std::fmt::Debug for cs_x86_op__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "cs_x86_op__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_cs_x86_op() {
    assert_eq!(
        ::std::mem::size_of::<cs_x86_op>(),
        48usize,
        concat!("Size of: ", stringify!(cs_x86_op))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_x86_op>(),
        8usize,
        concat!("Alignment of ", stringify!(cs_x86_op))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_x86_op>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_x86_op),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_x86_op>())).size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_x86_op),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_x86_op>())).avx_bcast as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_x86_op),
            "::",
            stringify!(avx_bcast)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_x86_op>())).avx_zero_opmask as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_x86_op),
            "::",
            stringify!(avx_zero_opmask)
        )
    );
}
impl ::std::fmt::Debug for cs_x86_op {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "cs_x86_op {{ type: {:?}, __bindgen_anon_1: {:?}, size: {:?}, avx_bcast: {:?}, avx_zero_opmask: {:?} }}" , self . type_ , self . __bindgen_anon_1 , self . size , self . avx_bcast , self . avx_zero_opmask )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cs_x86 {
    pub prefix: [u8; 4usize],
    pub opcode: [u8; 4usize],
    pub rex: u8,
    pub addr_size: u8,
    pub modrm: u8,
    pub sib: u8,
    pub disp: i32,
    pub sib_index: x86_reg,
    pub sib_scale: i8,
    pub sib_base: x86_reg,
    pub sse_cc: x86_sse_cc,
    pub avx_cc: x86_avx_cc,
    pub avx_sae: bool,
    pub avx_rm: x86_avx_rm,
    pub op_count: u8,
    pub operands: [cs_x86_op; 8usize],
}
#[test]
fn bindgen_test_layout_cs_x86() {
    assert_eq!(
        ::std::mem::size_of::<cs_x86>(),
        432usize,
        concat!("Size of: ", stringify!(cs_x86))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_x86>(),
        8usize,
        concat!("Alignment of ", stringify!(cs_x86))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_x86>())).prefix as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_x86),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_x86>())).opcode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_x86),
            "::",
            stringify!(opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_x86>())).rex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_x86),
            "::",
            stringify!(rex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_x86>())).addr_size as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_x86),
            "::",
            stringify!(addr_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_x86>())).modrm as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_x86),
            "::",
            stringify!(modrm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_x86>())).sib as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_x86),
            "::",
            stringify!(sib)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_x86>())).disp as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_x86),
            "::",
            stringify!(disp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_x86>())).sib_index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_x86),
            "::",
            stringify!(sib_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_x86>())).sib_scale as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_x86),
            "::",
            stringify!(sib_scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_x86>())).sib_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_x86),
            "::",
            stringify!(sib_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_x86>())).sse_cc as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_x86),
            "::",
            stringify!(sse_cc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_x86>())).avx_cc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_x86),
            "::",
            stringify!(avx_cc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_x86>())).avx_sae as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_x86),
            "::",
            stringify!(avx_sae)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_x86>())).avx_rm as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_x86),
            "::",
            stringify!(avx_rm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_x86>())).op_count as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_x86),
            "::",
            stringify!(op_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_x86>())).operands as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_x86),
            "::",
            stringify!(operands)
        )
    );
}
impl ::std::fmt::Debug for cs_x86 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "cs_x86 {{ prefix: {:?}, opcode: {:?}, rex: {:?}, addr_size: {:?}, modrm: {:?}, sib: {:?}, disp: {:?}, sib_index: {:?}, sib_scale: {:?}, sib_base: {:?}, sse_cc: {:?}, avx_cc: {:?}, avx_sae: {:?}, avx_rm: {:?}, op_count: {:?}, operands: {:?} }}" , self . prefix , self . opcode , self . rex , self . addr_size , self . modrm , self . sib , self . disp , self . sib_index , self . sib_scale , self . sib_base , self . sse_cc , self . avx_cc , self . avx_sae , self . avx_rm , self . op_count , self . operands )
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcore_op_type {
    XCORE_OP_INVALID = 0,
    XCORE_OP_REG = 1,
    XCORE_OP_IMM = 2,
    XCORE_OP_MEM = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcore_op_mem {
    pub base: u8,
    pub index: u8,
    pub disp: i32,
    pub direct: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcore_op_mem() {
    assert_eq!(
        ::std::mem::size_of::<xcore_op_mem>(),
        12usize,
        concat!("Size of: ", stringify!(xcore_op_mem))
    );
    assert_eq!(
        ::std::mem::align_of::<xcore_op_mem>(),
        4usize,
        concat!("Alignment of ", stringify!(xcore_op_mem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcore_op_mem>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcore_op_mem),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcore_op_mem>())).index as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcore_op_mem),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcore_op_mem>())).disp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcore_op_mem),
            "::",
            stringify!(disp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcore_op_mem>())).direct as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcore_op_mem),
            "::",
            stringify!(direct)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cs_xcore_op {
    pub type_: xcore_op_type,
    pub __bindgen_anon_1: cs_xcore_op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cs_xcore_op__bindgen_ty_1 {
    pub reg: ::std::os::raw::c_uint,
    pub imm: i32,
    pub mem: xcore_op_mem,
    _bindgen_union_align: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_cs_xcore_op__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cs_xcore_op__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(cs_xcore_op__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_xcore_op__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(cs_xcore_op__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_xcore_op__bindgen_ty_1>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_xcore_op__bindgen_ty_1),
            "::",
            stringify!(reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_xcore_op__bindgen_ty_1>())).imm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_xcore_op__bindgen_ty_1),
            "::",
            stringify!(imm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_xcore_op__bindgen_ty_1>())).mem as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_xcore_op__bindgen_ty_1),
            "::",
            stringify!(mem)
        )
    );
}
impl ::std::fmt::Debug for cs_xcore_op__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "cs_xcore_op__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_cs_xcore_op() {
    assert_eq!(
        ::std::mem::size_of::<cs_xcore_op>(),
        16usize,
        concat!("Size of: ", stringify!(cs_xcore_op))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_xcore_op>(),
        4usize,
        concat!("Alignment of ", stringify!(cs_xcore_op))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_xcore_op>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_xcore_op),
            "::",
            stringify!(type_)
        )
    );
}
impl ::std::fmt::Debug for cs_xcore_op {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "cs_xcore_op {{ type: {:?}, __bindgen_anon_1: {:?} }}",
            self.type_, self.__bindgen_anon_1
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cs_xcore {
    pub op_count: u8,
    pub operands: [cs_xcore_op; 8usize],
}
#[test]
fn bindgen_test_layout_cs_xcore() {
    assert_eq!(
        ::std::mem::size_of::<cs_xcore>(),
        132usize,
        concat!("Size of: ", stringify!(cs_xcore))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_xcore>(),
        4usize,
        concat!("Alignment of ", stringify!(cs_xcore))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_xcore>())).op_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_xcore),
            "::",
            stringify!(op_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_xcore>())).operands as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_xcore),
            "::",
            stringify!(operands)
        )
    );
}
impl ::std::fmt::Debug for cs_xcore {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "cs_xcore {{ op_count: {:?}, operands: {:?} }}",
            self.op_count, self.operands
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cs_detail {
    pub regs_read: [u8; 12usize],
    pub regs_read_count: u8,
    pub regs_write: [u8; 20usize],
    pub regs_write_count: u8,
    pub groups: [u8; 8usize],
    pub groups_count: u8,
    pub __bindgen_anon_1: cs_detail__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cs_detail__bindgen_ty_1 {
    pub x86: cs_x86,
    pub arm64: cs_arm64,
    pub arm: cs_arm,
    pub mips: cs_mips,
    pub ppc: cs_ppc,
    pub sparc: cs_sparc,
    pub sysz: cs_sysz,
    pub xcore: cs_xcore,
    _bindgen_union_align: [u64; 185usize],
}
#[test]
fn bindgen_test_layout_cs_detail__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cs_detail__bindgen_ty_1>(),
        1480usize,
        concat!("Size of: ", stringify!(cs_detail__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_detail__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cs_detail__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_detail__bindgen_ty_1>())).x86 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_detail__bindgen_ty_1),
            "::",
            stringify!(x86)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_detail__bindgen_ty_1>())).arm64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_detail__bindgen_ty_1),
            "::",
            stringify!(arm64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_detail__bindgen_ty_1>())).arm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_detail__bindgen_ty_1),
            "::",
            stringify!(arm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_detail__bindgen_ty_1>())).mips as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_detail__bindgen_ty_1),
            "::",
            stringify!(mips)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_detail__bindgen_ty_1>())).ppc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_detail__bindgen_ty_1),
            "::",
            stringify!(ppc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_detail__bindgen_ty_1>())).sparc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_detail__bindgen_ty_1),
            "::",
            stringify!(sparc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_detail__bindgen_ty_1>())).sysz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_detail__bindgen_ty_1),
            "::",
            stringify!(sysz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_detail__bindgen_ty_1>())).xcore as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_detail__bindgen_ty_1),
            "::",
            stringify!(xcore)
        )
    );
}
impl ::std::fmt::Debug for cs_detail__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "cs_detail__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_cs_detail() {
    assert_eq!(
        ::std::mem::size_of::<cs_detail>(),
        1528usize,
        concat!("Size of: ", stringify!(cs_detail))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_detail>(),
        8usize,
        concat!("Alignment of ", stringify!(cs_detail))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_detail>())).regs_read as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_detail),
            "::",
            stringify!(regs_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_detail>())).regs_read_count as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_detail),
            "::",
            stringify!(regs_read_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_detail>())).regs_write as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_detail),
            "::",
            stringify!(regs_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_detail>())).regs_write_count as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_detail),
            "::",
            stringify!(regs_write_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_detail>())).groups as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_detail),
            "::",
            stringify!(groups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_detail>())).groups_count as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_detail),
            "::",
            stringify!(groups_count)
        )
    );
}
impl ::std::fmt::Debug for cs_detail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "cs_detail {{ regs_read: {:?}, regs_read_count: {:?}, regs_write: {:?}, regs_write_count: {:?}, groups: {:?}, groups_count: {:?}, __bindgen_anon_1: {:?} }}" , self . regs_read , self . regs_read_count , self . regs_write , self . regs_write_count , self . groups , self . groups_count , self . __bindgen_anon_1 )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cs_insn {
    pub id: ::std::os::raw::c_uint,
    pub address: u64,
    pub size: u16,
    pub bytes: [u8; 16usize],
    pub mnemonic: [::std::os::raw::c_char; 32usize],
    pub op_str: [::std::os::raw::c_char; 160usize],
    pub detail: *mut cs_detail,
}
#[test]
fn bindgen_test_layout_cs_insn() {
    assert_eq!(
        ::std::mem::size_of::<cs_insn>(),
        240usize,
        concat!("Size of: ", stringify!(cs_insn))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_insn>(),
        8usize,
        concat!("Alignment of ", stringify!(cs_insn))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_insn>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_insn),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_insn>())).address as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_insn),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_insn>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_insn),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_insn>())).bytes as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_insn),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_insn>())).mnemonic as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_insn),
            "::",
            stringify!(mnemonic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_insn>())).op_str as *const _ as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_insn),
            "::",
            stringify!(op_str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cs_insn>())).detail as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_insn),
            "::",
            stringify!(detail)
        )
    );
}
impl ::std::fmt::Debug for cs_insn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "cs_insn {{ id: {:?}, address: {:?}, size: {:?}, bytes: {:?}, mnemonic: [{}], op_str: [{}], detail: {:?} }}" , self . id , self . address , self . size , self . bytes , self . mnemonic . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . op_str . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . detail )
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cs_err {
    CS_ERR_OK = 0,
    CS_ERR_MEM = 1,
    CS_ERR_ARCH = 2,
    CS_ERR_HANDLE = 3,
    CS_ERR_CSH = 4,
    CS_ERR_MODE = 5,
    CS_ERR_OPTION = 6,
    CS_ERR_DETAIL = 7,
    CS_ERR_MEMSETUP = 8,
    CS_ERR_VERSION = 9,
    CS_ERR_DIET = 10,
    CS_ERR_SKIPDATA = 11,
    CS_ERR_X86_ATT = 12,
    CS_ERR_X86_INTEL = 13,
}
extern "C" {
    pub fn cs_version(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn cs_support(query: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn cs_open(arch: cs_arch, mode: cs_mode, handle: *mut csh) -> cs_err;
}
extern "C" {
    pub fn cs_close(handle: *mut csh) -> cs_err;
}
extern "C" {
    pub fn cs_option(handle: csh, type_: cs_opt_type, value: usize) -> cs_err;
}
extern "C" {
    pub fn cs_errno(handle: csh) -> cs_err;
}
extern "C" {
    pub fn cs_strerror(code: cs_err) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cs_disasm(
        handle: csh,
        code: *const u8,
        code_size: usize,
        address: u64,
        count: usize,
        insn: *mut *mut cs_insn,
    ) -> usize;
}
extern "C" {
    pub fn cs_disasm_ex(
        handle: csh,
        code: *const u8,
        code_size: usize,
        address: u64,
        count: usize,
        insn: *mut *mut cs_insn,
    ) -> usize;
}
extern "C" {
    pub fn cs_free(insn: *mut cs_insn, count: usize);
}
extern "C" {
    pub fn cs_malloc(handle: csh) -> *mut cs_insn;
}
extern "C" {
    pub fn cs_disasm_iter(
        handle: csh,
        code: *mut *const u8,
        size: *mut usize,
        address: *mut u64,
        insn: *mut cs_insn,
    ) -> bool;
}
extern "C" {
    pub fn cs_reg_name(
        handle: csh,
        reg_id: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cs_insn_name(
        handle: csh,
        insn_id: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cs_group_name(
        handle: csh,
        group_id: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cs_insn_group(
        handle: csh,
        insn: *const cs_insn,
        group_id: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn cs_reg_read(handle: csh, insn: *const cs_insn, reg_id: ::std::os::raw::c_uint) -> bool;
}
extern "C" {
    pub fn cs_reg_write(handle: csh, insn: *const cs_insn, reg_id: ::std::os::raw::c_uint) -> bool;
}
extern "C" {
    pub fn cs_op_count(
        handle: csh,
        insn: *const cs_insn,
        op_type: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cs_op_index(
        handle: csh,
        insn: *const cs_insn,
        op_type: ::std::os::raw::c_uint,
        position: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
